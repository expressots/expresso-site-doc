---
sidebar_position: 4
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Prisma Provider

O Provedor Prisma do ExpressoTS encapsula o robusto ORM (Object-Relational Mapper) [Prisma](https://www.prisma.io/) dentro do framework ExpressoTS, criando uma interface transparente para opera√ß√µes de dados. O Prisma facilita um acesso seguro, tipo-seguro e simplificado ao seu banco de dados, garantindo que as intera√ß√µes de dados dentro das suas aplica√ß√µes sejam precisas e eficientes. Seu potente motor de consulta simplifica significativamente o acesso ao banco de dados e mitiga bugs comuns associados √† recupera√ß√£o e manipula√ß√£o de dados.

## Como Instalar

Aproveitar as capacidades do Prisma dentro do seu framework ExpressoTS √© simplificado com a ajuda do [ExpressoTS CLI](https://github.com/expressots/expressots-cli). O CLI fornece um assistente dedicado para simplificar a configura√ß√£o do Prisma, garantindo uma integra√ß√£o sem complica√ß√µes.

```bash title="terminal"
expressots add prisma

- Type the prisma client version (default=latest): (latest)
- Type the schema name (default=schema): (schema)
- Where do you want to save your prisma schema (default=./): (.)
- Select your database:
  CockroachDB
  Microsoft SQL Server
  MongoDB
  MySQL
> PostgreSQL
  SQLite
- Do you want to install the latest recommended database driver for PostgreSQL? (Y/n)
- Do you want to add BaseRepository Pattern in this project? this will replace the existing BaseRepository and BaseRepositoryInterface if it exists. (Y/n)
```

Ao seguir estas instru√ß√µes, o ExpressoTS garante uma instala√ß√£o e configura√ß√£o sem problemas do Prisma, adaptadas √†s necessidades do seu projeto.

## Atualiza√ß√£o de Configura√ß√£o

Ap√≥s a instala√ß√£o, um novo conjunto de configura√ß√µes referentes ao provedor Prisma est√° dispon√≠vel para voc√™ ajustar. Isso inclui schemaName, schemaPath, entitiesPath e entityNamePattern. Personalize essas configura√ß√µes para se alinhar com a arquitetura e conven√ß√µes de nomenclatura do seu projeto.

```ts title="expressots.config.ts"
import { ExpressoConfig, Pattern } from "@expressots/core";

const config: ExpressoConfig = {
  sourceRoot: "src",
  scaffoldPattern: Pattern.KEBAB_CASE,
  opinionated: true,
  providers: {
    // highlight-start
    prisma: {
      schemaName: "schema",
      schemaPath: "./prisma",
      entitiesPath: "entities",
      entityNamePattern: "entity",
    },
    // highlight-end
  },
};

export default config;
```

## Extens√£o do Reposit√≥rio Base
Durante o processo de configura√ß√£o, ser√° solicitado a voc√™ estender o seu reposit√≥rio base existente ou criar um novo, caso nenhum exista. Isso inclui tanto a interface quanto a implementa√ß√£o, permitindo uma maneira padronizada de interagir com suas entidades de banco de dados.

<Tabs>

  <TabItem label="Interface" value="interface">

```ts title="./src/repositories/base-repository.interface.ts"
import { Prisma, PrismaClient } from "@prisma/client";
import {
  CreateInput,
  ModelsOf,
  DeleteWhere,
  Select,
  PrismaAction,
} from "@expressots/prisma";

interface IBaseRepository<ModelName extends ModelsOf<PrismaClient>> {
  // highlight-start
  aggregate: (args: PrismaAction<ModelName, "aggregate">) => Promise<any>;
  count: (args: PrismaAction<ModelName, "count">) => Promise<number>;
  // highlight-end
  create: (
    data:
      | CreateInput<ModelName>["data"]
      | {
          data: CreateInput<ModelName>["data"];
          select?: Select<ModelName, "create">["select"];
        },
  ) => Promise<ModelName | never>;
  // ...
}
```

  </TabItem>

  <TabItem label="Implementation" value="implementation">

```ts title="./src/repositories/base-repository.ts"
import { PrismaClient, Prisma } from "@prisma/client";
import {
  CreateInput,
  ModelsOf,
  DeleteWhere,
  Select,
  PrismaAction,
} from "@expressots/prisma";
import { provide } from "inversify-binding-decorators";
import { IBaseRepository } from "./base-repository.interface";

@provide(BaseRepository)
class BaseRepository<ModelName extends ModelsOf<PrismaClient>>
  implements IBaseRepository<ModelName>
{
  protected prismaModel: any;
  protected prismaClient: PrismaClient;
  constructor(modelName: keyof PrismaClient) {
    this.prismaClient = new PrismaClient();
    this.prismaModel = this.prismaClient[modelName];
  }

  // highlight-start
  async aggregate(args: PrismaAction<ModelName, "aggregate">): Promise<any> {
    return await this.prismaModel.aggregate(args);
  }
  // highlight-end

  // highlight-start
  async count(args: PrismaAction<ModelName, "count">): Promise<number> {
    return await this.prismaModel.count(args);
  }
  // highlight-end
```

  </TabItem>

</Tabs>

## Utilizando Decoradores Prisma do ExpressoTS

Desenvolvemos decoradores para facilitar o uso do Prisma com o ExpressoTS. Voc√™ pode usar os decoradores com Entidades, enums e tipos para gerar o esquema Prisma automaticamente.

### Decoradores
| Decorador	| Descri√ß√£o	| Op√ß√µes | 
| --- | --- | --- |
| @prismaModel	| Decora uma classe como um modelo Prisma	| map |
| @prismaField	| Decora uma propriedade com atributo espec√≠fico do banco de dados	| attr, isId, isOptional, type, isUnique, prismaDefault, mapField, name |
| @prismaRelation	| Decora uma propriedade como uma rela√ß√£o Prisma	| relation, name, model, refs, fields, onDelete, onUpdate, isRequired |
| @prismaIndex |	Decora uma propriedade como um √≠ndice Prisma	| name, fields, map, type |

### Decorador PrismaModel
O decorador @prismaModel() √© essencial para designar uma classe como um modelo Prisma, o que por sua vez desencadeia a gera√ß√£o autom√°tica do esquema Prisma correspondente.

Op√ß√µes:
- `map`: A op√ß√£o map est√° dispon√≠vel para mapear o nome da classe para um nome diferente no esquema Prisma, garantindo a flexibilidade de aderir √†s conven√ß√µes ou requisitos de nomenclatura. Para uma compreens√£o aprofundada da op√ß√£o de mapa, consulte a documenta√ß√£o do Prisma.

Vamos ilustrar isso com um exemplo extra√≠do do modelo Opinativo. Inicialmente, a entidade est√° estruturada da seguinte forma:

<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>

<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>

```mermaid
classDiagram
class User {
    +id: string
    +name: string
    +email: string
    +constructor()
}
```

</div>

<div style={{ flex: 1 }}>

```ts title="./src/entities/user.entity.ts"
import { provide } from "inversify-binding-decorators";
import { randomUUID } from "node:crypto";
import { IEntity } from "./base.entity";

// highlight-start
@provide(User)
export class User implements IEntity {
  id: string;
  name!: string;
  email!: string;

  constructor() {
    this.id = randomUUID();
  }
}
// highlight-end
```

</div>

</div>

A √∫nica adi√ß√£o necess√°ria para come√ßar √© o decorador `@prismaModel()` √† classe:

<Tabs>

<TabItem label="Entity" value="entity">

```ts title="./src/entities/user.entity.ts"
import { provide } from "inversify-binding-decorators";
import { randomUUID } from "node:crypto";
import { IEntity } from "./base.entity";
// highlight-start
import { prismaModel } from "@expressots/prisma";
// highlight-end

@provide(User)
// highlight-start
@prismaModel({ map: "user" })
// highlight-end
export class User implements IEntity {
  id: string;
  name!: string;
  email!: string;

  constructor() {
    this.id = randomUUID();
  }
}
```

</TabItem>


<TabItem label="Terminal" value="terminal">

```bash title="Terminal"
npm run prisma
```

</TabItem>

<TabItem label="Prisma Schema" value="prisma-schema">

```typescript title="./prisma/schema.prisma"
model User {

  @@map("users")
}
```

</TabItem>
</Tabs>

---

Ao executar isso, voc√™ poder√° encontrar uma mensagem de erro conforme mostrado abaixo. Este √© um comportamento previsto, pois o Prisma exige pelo menos um crit√©rio exclusivo por modelo e n√£o fornecemos nenhum por meio dos decoradores.

```ansii
error: Error validating model "User": Each model must have at least one unique criteria that has only required fields. Either mark a single field with `@id`, `@unique` or add a multi field criterion with `@@id([])` or `@@unique([])` to the model.
  -->  schema.prisma:13
   |
12 |
13 | model User {
14 |
15 |   @@map("users")
16 | }
   |
```

:::note
Para gerar o modelo Prisma, `@prismaModel()` deve ser usado o decorador. Todas as entidades devem ser decoradas com `@prismaModel()`.
:::

### Decorador PrismaField

O decorador `@prismaField()` √© usado para decorar uma propriedade com atributos espec√≠ficos do prisma dispon√≠veis na [documenta√ß√£o do Prisma](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference# campos do modelo).

Op√ß√µes:

- `attr`: Voc√™ pode usar a op√ß√£o `attr` para adicionar atributos espec√≠ficos ao campo por banco de dados. Para obter mais informa√ß√µes sobre a op√ß√£o `attr`, consulte a [documenta√ß√£o do Prisma](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#model-fields).



<Tabs>

<TabItem label="Entity" value="entity">

```ts title="./src/entities/user.entity.ts"
import { provide } from "inversify-binding-decorators";
import { randomUUID } from "node:crypto";
import { IEntity } from "./base.entity";
import { prismaModel, prismaField, db } from "@expressots/prisma";

@provide(User)
@prismaModel({ map: "users" })
export class User implements IEntity {
  @prismaField({ attr: db.Postgres.Uuid, isUnique: true, isId: true })
  id: string;

  @prismaField({ attr: db.Postgres.Char(36) })
  name!: string;

  @prismaField({ attr: db.Postgres.Char(36) })
  email!: string;

  constructor() {
    this.id = randomUUID();
  }
}
```

</TabItem>

<TabItem label="Terminal" value="terminal">

```bash title="Terminal"
npm run prisma
```

</TabItem>


<TabItem label="Prisma Schema" value="prisma-schema">

```typescript title="./prisma/schema.prisma"
model User {
  // highlight-start
  id    String @id @unique @db.Uuid
  name  String @db.Char(36)
  email String @db.Char(36)
  // highlight-end

  @@map("user")
}
```

</TabItem>
</Tabs>

:::note
`db` √© um namespace que cont√©m todos os atributos dispon√≠veis por banco de dados.
:::

### Decorador de Rela√ß√£o Prisma

O decorador `@prismaRelation()` √© um recurso poderoso que agiliza a cria√ß√£o de relacionamentos entre modelos Prisma. Simplifica o processo ao permitir a defini√ß√£o de rela√ß√µes a partir da perspectiva do modelo onde o relacionamento √© iniciado de forma mais l√≥gica. Isso significa que em vez de definir uma chave estrangeira em um modelo filho, voc√™ pode declarar o relacionamento no modelo pai, o que pode ser mais intuitivo, especialmente ao lidar com relacionamentos um-para-muitos (1-M).

As op√ß√µes para `@prismaRelation()` incluem:

- `model`: Especifica o modelo Prisma relacionado.
- `rela√ß√£o`: Define o tipo de relacionamento, como um para muitos, um para um, etc.
- `refs`: Uma matriz que denota o(s) campo(s) aos quais o relacionamento est√° referenciando.
- `fields`: Especifica o(s) campo(s) no modelo que s√£o usados para a rela√ß√£o.
- `onDelete` e `onUpdate`: Definem as a√ß√µes referenciais nas opera√ß√µes de exclus√£o e atualiza√ß√£o.
- `isRequired`: Determina se o campo relacionado √© obrigat√≥rio.

Agora, vamos aplicar isso a um exemplo espec√≠fico para melhor compreens√£o.

#### Exemplo: relacionamento User-Post


<div style={{ display: 'flex', justifyContent: 'center', gap: '2rem' }}>

<div style={{ display: "flex", width: "50%" }}>

```mermaid
classDiagram
  class User {
    +String id
    +String name
    +String email
    +Array~Post~ posts
  }
  class Post {
    +String id
  }

  User "1" --> "*" Post : has many
```

</div>

<div>

Considere uma plataforma de blog onde um usu√°rio pode criar v√°rias postagens. Queremos definir um relacionamento um-para-muitos dos modelos `User` para `Post`. Do ponto de vista do desenvolvimento de aplica√ß√µes, √© mais natural expressar que um usu√°rio ‚Äútem muitas‚Äù postagens do que dizer que uma postagem ‚Äúpertence a‚Äù um usu√°rio. Com o decorador `@prismaRelation()`, podemos declarar diretamente esse relacionamento no modelo `User`.

</div>

</div>

Veja como podemos usar o decorador `@prismaRelation()` no contexto:

<Tabs>

<TabItem label="User Entity" value="user-entity">

```ts title="./src/entities/user.entity.ts"
import { provide } from "inversify-binding-decorators";
import { randomUUID } from "node:crypto";
import { IEntity } from "./base.entity";
import {
  prismaModel,
  prismaField,
  // highlight-start
  prismaRelation,
  Relation,
  // highlight-end
  db,
} from "@expressots/prisma";
import { Post } from "./post.entity";

@provide(User)
@prismaModel({ map: "user" })
export class User implements IEntity {
  @prismaField({ attr: db.Postgres.Uuid, isUnique: true, isId: true })
  id: string;

  @prismaField({ attr: db.Postgres.Char(36) })
  name!: string;

  @prismaField({ attr: db.Postgres.Char(36) })
  email!: string;

  // highlight-start
  // Define the one-to-many relationship to Post.
  @prismaField({ type: Post })
  @prismaRelation({
    model: "Post",
    relation: Relation.OneToMany,
    refs: ["id"],
  })
  posts: Post[]; // This is where the User-Post relationship is expressed.
  // highlight-end

  constructor() {
    this.id = randomUUID();
  }
}
```

</TabItem>

<TabItem label="Post Entity" value="post-entity">

```ts title="./src/entities/post.entity.ts"
import { provide } from "inversify-binding-decorators";
import { prismaModel, prismaField } from "@expressots/prisma";
import { randomUUID } from "node:crypto";

@prismaModel({ map: "posts" })
@provide(Post)
export class Post {
    @prismaField({ isId: true })
    id: string;

    // highlight-next-line
    // No need to explicitly define the foreign key field here; it's handled by the provider. ü•≥

    constructor() {
        this.id = randomUUID();
    }
}
```

</TabItem>

<TabItem label="Terminal" value="terminal">

```bash title="Terminal"
npm run prisma
```

</TabItem>


<TabItem label="Prisma Schema" value="prisma-schema">

```typescript title="./prisma/schema.prisma"
model User {
  id    String @id @unique @db.Uuid
  name  String @db.Char(36)
  email String @db.Char(36)
  // highlight-next-line
  posts Post[]

  @@map("user")
}

model Post {
  id     String  @id @unique @db.Uuid
  // highlight-start
  user   User?   @relation(fields: [userId], references: [id])
  userId String? @unique
  // highlight-end

  @@map("posts")
}
```

</TabItem>
</Tabs>

Neste exemplo, o modelo `User` usa o decorador `@prismaRelation()` para declarar sua conex√£o com m√∫ltiplas inst√¢ncias `Post`. O Prisma cuidar√° automaticamente da cria√ß√£o da chave estrangeira correspondente no modelo `Post`, tornando o relacionamento gerenciado de forma expl√≠cita e impl√≠cita, reduzindo assim o potencial de erro e confus√£o.

:::observa√ß√£o
A sintaxe declarativa do decorador `@prismaRelation()` se alinha estreitamente com a forma como os desenvolvedores conceituam os relacionamentos no aplicativo, fornecendo uma ponte entre o modelo de objeto e o esquema de banco de dados subjacente.
:::

### Decorador PrismaIndex

O decorador `@prismaIndex()` √© essencial para otimizar consultas ao banco de dados, definindo √≠ndices em campos espec√≠ficos de um modelo Prisma. Os √≠ndices s√£o tabelas de pesquisa especiais que o mecanismo de pesquisa do banco de dados pode usar para acelerar a recupera√ß√£o de dados. A indexa√ß√£o adequada de um banco de dados pode melhorar drasticamente o desempenho de um aplicativo.

Ao aplicar o decorador `@prismaIndex()` a um modelo, voc√™ fornece ao Prisma as informa√ß√µes necess√°rias para criar um √≠ndice no banco de dados subjacente. O decorador pega um objeto com diversas op√ß√µes:

- `name`: Especifica um nome para o √≠ndice, permitindo f√°cil refer√™ncia e gerenciamento.
- `fields`: Define um array de campos a serem inclu√≠dos no √≠ndice. Estas s√£o as propriedades do modelo que voc√™ espera consultar com frequ√™ncia.
- `type`: Dita o tipo de √≠ndice a ser utilizado, influenciando como o banco de dados organiza e recupera os dados.

#### Tipos de √≠ndice

O enum `IndexType` oferece uma sele√ß√£o de tipos de √≠ndice adequados para diferentes tipos de dados e padr√µes de consulta:

- `Brin`: √çndices de intervalo de blocos s√£o adequados para tabelas grandes nas quais certas colunas t√™m uma correla√ß√£o linear com sua localiza√ß√£o f√≠sica no disco.
- `Btree`: Os √≠ndices de √°rvore balanceada s√£o os mais comuns e excelentes para uso geral. Eles suportam consultas de igualdade e intervalo de forma eficiente.
- `Gist`: √≠ndices de √°rvore de pesquisa generalizada suportam tipos complexos como dados geom√©tricos e podem lidar com dados multidimensionais.
- `Gin`: √çndices invertidos generalizados s√£o otimizados para indexar valores compostos onde cada item indexado pode conter v√°rios valores de componentes.
- `Hash`: Os √≠ndices hash fornecem recupera√ß√£o r√°pida para pesquisas de igualdade, mas n√£o suportam consultas de intervalo.
- `Spgist`: √≠ndices de √°rvore de pesquisa generalizada particionados em espa√ßo s√£o bons para dados que n√£o se ajustam bem a uma estrutura de √°rvore B, como n√∫meros de telefone ou endere√ßos IP.

Cada tipo de √≠ndice vem com suas pr√≥prias caracter√≠sticas de desempenho e √© otimizado para tipos espec√≠ficos de consultas e padr√µes de dados. A escolha do tipo de √≠ndice correto √© crucial para o desempenho das opera√ß√µes de leitura e, consequentemente, para o desempenho geral da aplica√ß√£o.

#### Exemplo de uso

Abaixo est√° um exemplo de como usar o decorador `@prismaIndex()` para definir um √≠ndice hash no campo `email` de um modelo `User`, o que aceleraria consultas que procuram usu√°rios por seus endere√ßos de email:


<Tabs>

<TabItem label="Entity" value="entity">

```ts title="./src/entities/user.entity.ts"
import {
  prismaModel,
  prismaField,
  prismaRelation,
  // highlight-next-line
  prismaIndex,
  Relation,
  // highlight-next-line
  IndexType,
  db,
} from "@expressots/prisma";

@provide(User)
@prismaModel({ map: "user" })
// highlight-next-line
@prismaIndex({ name: "emailIndex", fields: ["email"], type: IndexType.Hash })
export class User implements IEntity {
  // ...

  // highlight-next-line
  @prismaField({ attr: db.Postgres.Char(36), isUnique: true })
  email!: string;
}
```

</TabItem>

<TabItem label="Terminal" value="terminal">

```bash title="Terminal"
npm run prisma
```

</TabItem>

<TabItem label="Prisma Schema" value="prisma-schema">

```prisma title="./prisma/schema.prisma"
model User {
  email String @db.Char(36)

  @@unique([id, email])
  @@index([email], name: "emailIndex", type: Hash)
  @@map("user")
}
```

</TabItem>
</Tabs>

:::note
Os √≠ndices s√£o cruciais para otimizar seu banco de dados, mas devem ser usados criteriosamente, pois podem afetar o desempenho de grava√ß√£o e consumir armazenamento adicional.
:::

---

## Apoie o projeto

ExpressoTS √© um projeto de c√≥digo aberto licenciado sob o MIT. √â um projeto independente com desenvolvimento cont√≠nuo possibilitado gra√ßas ao seu suporte. Se voc√™ deseja ajudar, por favor considere:

- Se tornar um **[Sponsor no GitHub](https://github.com/sponsors/expressots)**
- Siga a **[organiza√ß√£o](https://github.com/expressots)** no GitHub e de um Star ‚≠ê no projeto
- Subscreva no nosso canal na Twitch: **[Richard Zampieri](https://www.twitch.tv/richardzampieri)**
- Entre no nosso **[Discord](https://discord.com/invite/PyPJfGK)**
- Contribua submetendo **[issues e pull requests](https://github.com/expressots/expressots/issues/new/choose)**
- Compartilhe o projeto com seus amigos e colegas
